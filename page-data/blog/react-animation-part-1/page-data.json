{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/react-animation-part-1/","result":{"data":{"blogPost":{"id":"0b8605b9-8e72-5fe4-9bc3-66126f647ee0","html":"<p>React's fundamental principle is UI as a function of state. The state changes, we re-render and get a new UI.</p>\n<p>This seems obvious, but when I first dipped my toe into JavaScript, it was some jQuery. Rather than declaratively saying what the UI should look like, you imperatively manipulated the UI. Button clicked - move that there. User types - show message. This caused all sorts of challenges that React helps address, like an explosion of complexity as more features are added.</p>\n<p>But it did have one thing going for it - it was a very obvious point to add animation. Move that there becomes <em>slide</em> that there. Show message becomes <em>fade in</em> message. React doesn't immediately give us anywhere to tell it <em>how</em> to transform one UI (i.e. a render output) to another, it just works out the required changes and updates the DOM. So we need some extra help.</p>\n<p>A major challenge with web animations is often performance. End users are very likely to have worse hardware than we're developing on; it might be old, it might be mobile, it might be old and mobile, or worst of all, it might be IE... So I've picked a toolkit for animations with an eye on performance.</p>\n<p>I have two preferred techniques for adding animation: CSS animations and React Spring. There are others which I'll touch on at the end.</p>\n<h2>CSS Animations</h2>\n<p>When writing CSS for my React apps, I prefer to use <code class=\"language-text\">styled-components</code>. CSS-in-JS makes a lot of sense to me, I like to keep all the code for delivering something in the same place if possible, so I don't see an immediate need to split it into a separate file based on technology. I also find that declaring everything effectively as a component encourages me to reuse bits more than e.g. CSS modules. And it just works. But everything I talk about in the rest of this would work with a different CSS-in-JS solution or separate CSS files.</p>\n<p>Performance-wise, browsers are already well optimised for CSS. Lots of properties are <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_animated_properties\">animatable</a>, but there are certain properties that they're better at animating <a href=\"https://www.html5rocks.com/en/tutorials/speed/high-performance-animations/\">position, scale, rotation and opacity</a>. If we stick to these guys, we can be pretty confident that we can get nice smooth animations.</p>\n<p>CSS has two main ways to introduce animation, the <code class=\"language-text\">transition</code> and <code class=\"language-text\">animation</code> properties.</p>\n<h3>Transitions</h3>\n<p>The <code class=\"language-text\">transition</code> property defines how changes in other CSS properties get applied. By default, if you change another property (e.g. by applying another class or a pseudo-class), it just gets applied immediately. But with a <code class=\"language-text\">transition</code> we can get it applied gradually, with the browser automatically calculating the intermediate steps.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> Button <span class=\"token operator\">=</span> styled<span class=\"token punctuation\">.</span>button<span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">\n  background-color: papayawhip;\n  transition: transform 200ms;\n  transition: background-color 500ms;\n  &amp;:hover {\n    transform: scale(1.2);\n  }\n  </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token parameter\">props</span> <span class=\"token operator\">=></span> props<span class=\"token punctuation\">.</span>active <span class=\"token operator\">&amp;&amp;</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">\n    background-color: palevioletred;\n  </span><span class=\"token template-punctuation string\">`</span></span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">;\n</span><span class=\"token template-punctuation string\">`</span></span></code></pre></div>\n<p>This button component will grow slightly when hovered (when the <code class=\"language-text\">:hover</code> pseudo-class is applied) and turn palevioletred when the <code class=\"language-text\">active</code> prop is true. In the actual implementation, this corresponds to a different class being applied with the new background colour. The transitions will be applied linearly (the default) over 200 and 500 milliseconds respectively. We could add delays to the animation, or use different <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/transition-timing-function\">timing functions</a>.</p>\n<p>The hover effect is applied without React needing to do a re-render. The active state is applied with a single re-render updating the <code class=\"language-text\">active</code> prop, with the browser calculating all of the intermediate states. All in all, we're not executing much JavaScript to make these animations work, so we can assume they'll be fast.</p>\n<p>Good for:</p>\n<ul>\n<li>Simple transitions between states</li>\n<li>High performance</li>\n</ul>\n<p>Less good for:</p>\n<ul>\n<li>Components being added/removed</li>\n<li>Sequencing multiple animations</li>\n<li>Realistic motion (more later...)</li>\n</ul>\n<h3>Keyframe Animations</h3>\n<p>Some animations, particularly more decorative ones, aren't just a simple direct transition between two states. Some animations run continuously (preferably with restraint...), others we may just want more control over the path between states. This is where keyframe animations come in.</p>\n<p>The first problem we can solve with this is the fade in of a new element. CSS transitions can't do this, because the element must have been rendered with the initial styles to then update them.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> fadeIn <span class=\"token operator\">=</span> keyframes<span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">\nfrom {\n  opacity: 0;\n}\nto {\n  opacity: 1;\n}\n</span><span class=\"token template-punctuation string\">`</span></span>\n<span class=\"token keyword\">const</span> Button <span class=\"token operator\">=</span> styled<span class=\"token punctuation\">.</span>button<span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">\n  animation: 200ms </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>fadeIn<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">;\n  animation-fill-mode: both;\n</span><span class=\"token template-punctuation string\">`</span></span></code></pre></div>\n<p>This button will fade in over 200ms when it is first rendered. The <code class=\"language-text\">animation-fill-mode</code> tells it to use the \"from\" opacity before the animation and keep the \"to\" opacity afterwards.</p>\n<p>We can also make a continuous animation.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> pulse <span class=\"token operator\">=</span> keyframes<span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">\n0% {\n  transform: scale(1);\n}\n50% {\n  transform: scale(1.2);\n}\n100% {\n  transform: scale(1);\n}\n</span><span class=\"token template-punctuation string\">`</span></span>\n<span class=\"token keyword\">const</span> PulsingButton <span class=\"token operator\">=</span> styled<span class=\"token punctuation\">.</span>button<span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">\n  animation: 200ms </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>pulse<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> infinite;\n</span><span class=\"token template-punctuation string\">`</span></span></code></pre></div>\n<p>Here you can also see that we can start to script more elaborate animations, and we could animate multiple properties at the same time, such as making it scale and rotate. But each element's animations are going to run independently of each other, so we would have to do some elaborate scheduling to sequence animations between multiple elements.</p>\n<p>In both of these cases, the animations are achieved with a single React render. Again, no JavaScript execution per frame of animation, so the browser can optimise it well.</p>\n<p>Good for:</p>\n<ul>\n<li>High performance</li>\n<li>Entrance animations</li>\n<li>Continuous animations</li>\n<li>More sequencing</li>\n</ul>\n<p>Less good for:</p>\n<ul>\n<li>Exit animations</li>\n<li>Coordinating animations between elements</li>\n<li>Realistic motion (ish)</li>\n</ul>\n<h3>React Transition Group</h3>\n<p>Both of these CSS techniques depend on the elements being animated being present in the DOM at both the start and finish of the animations. For state changes and entrances, that's fine, but when elements are being removed, React will remove the element from the DOM straight away, not waiting around to see if we want to animate its departure.</p>\n<p>React transition group is a component that can help us with this, while continuing to use high performance CSS animations. For exits, it renders your component first with an <code class=\"language-text\">exit</code> class, then <code class=\"language-text\">exit-active</code> and finally <code class=\"language-text\">exit-done</code> (or optionally to actually unmount your component and remove it from the DOM). It forces a re-render between each class change, to allow your animation to be applied using the <code class=\"language-text\">transition</code> property.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> Button <span class=\"token operator\">=</span> styled<span class=\"token punctuation\">.</span>button<span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">\n  transition: all 200ms;\n  &amp;.fade-enter {\n    opacity: 0;\n    transform: scale(0.8);\n  }\n  &amp;.fade-enter-active {\n    opacity: 1;\n    transform: scale(1);\n  }\n  &amp;.fade-exit {\n    opacity: 1;\n    transform: scale(1);\n  }\n  &amp;.fade-exit-active {\n    opacity: 0;\n    transform: scale(0.8);\n  }\n</span><span class=\"token template-punctuation string\">`</span></span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">FadeInOutButton</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> show <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">CSSTransition</span></span>\n      <span class=\"token attr-name\">in</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>show<span class=\"token punctuation\">}</span></span>\n      <span class=\"token attr-name\">unmountOnExit</span>\n      <span class=\"token attr-name\">classNames</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>fade<span class=\"token punctuation\">\"</span></span>\n      <span class=\"token attr-name\">timeout</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token number\">200</span><span class=\"token punctuation\">}</span></span>\n      <span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Button</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Click Me!</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token class-name\">Button</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token class-name\">CSSTransition</span></span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>When <code class=\"language-text\">show</code> becomes true, the button is immediately added to the DOM, but with the <code class=\"language-text\">fade-enter</code> class so it is not visible. The <code class=\"language-text\">CSSTransition</code> component immediately replaces the <code class=\"language-text\">fade-enter</code> class with <code class=\"language-text\">fade-enter-active</code>, triggering the opacity and scale transitions. When <code class=\"language-text\">show</code> becomes false, it does the reverse (<code class=\"language-text\">fade-exit</code> then <code class=\"language-text\">fade-exit-active</code>), before unmounting the button (because <code class=\"language-text\">unmountOnExit</code> is set). The animation duration must be coordinated between the CSS transition duration and the <code class=\"language-text\">timeout</code> prop.</p>\n<p>Good for:</p>\n<ul>\n<li>Animating in and out</li>\n</ul>\n<p>Less good for:</p>\n<ul>\n<li>Interruptible transitions</li>\n<li>Coordinating animations between elements</li>\n<li>Realistic motion</li>\n</ul>\n<p>Pure CSS animations are great for high performance, and relatively simple transitions. But there have been a few gaps in what we can achieve with them:</p>\n<ul>\n<li>Interruptible animations</li>\n<li>Animations coordinated between elements</li>\n<li>Realistic motion (ish)</li>\n<li>Animations driven by numeric/continuous values, rather than discrete values.</li>\n</ul>\n<p>For these, we'll need to break out into JavaScript-land, which we'll do in part 2!</p>","frontmatter":{"title":"Animation in React - Tools - Part 1","date":"9 May 2020"},"fields":{"slug":"/blog/react-animation-part-1/"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/blog/react-animation-part-1/"}}}